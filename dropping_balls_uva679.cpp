// 直接模拟最后一个小球路线
// 每个小球落在各个节点上，如果是第奇数次落在此节点，则走左子树，第偶数次走右子树
// 然后接着求下一个节点是第奇数次还是第偶数次，直到求到最底层
#include <cstdio>
int main()
{
    int T, D, I;
    scanf("%d", &T);
    while (T--)
    {
        scanf("%d%d", &D, &I);
        int k = 1;
        for (int i = 0; i < D - 1; i++)
            if (I % 2)
            {
                // 如果小球是第奇数个落在此节点
                k = k * 2; // 走左子树
                I = (I + 1) / 2; // 是走左子树的第（i+1）/2个小球
            }
            else
            {
                // 如果小球是第偶数个落在此节点
                k = k * 2 + 1; // 走右子树
                I /= 2; // 是走右子树的第i/2个小球
            }
        printf("%d\n", k);
    }
    return 0;
}